#include "grafo.h"


struct grafo_ {
    int n_vertices;
    int n_arestas;
    PoP ** pontos;
    Lista ** arestas;
};

struct pop_ {
    char * nome;
    int grau;
    float lat;
    float lng;
};

Grafo * criar_grafo(int n_vertices) {
    if (n_vertices <= 0) return NULL;
    int i, k;

    Grafo * grafo = malloc(sizeof(struct grafo_));
    if (grafo == NULL) return NULL;

    grafo->pontos = (PoP**) malloc(n_vertices * sizeof(PoP*));
    if (grafo->pontos == NULL) {
        free(grafo);
        return NULL;
    }

    for (i = 0; i < n_vertices; i++) {
        grafo->pontos[i] = NULL;
    }

    grafo->arestas = malloc(n_vertices * sizeof(Lista *));

    if (grafo->arestas == NULL) {
        free(grafo->pontos); free(grafo);
        return NULL;
    }

    for (i = 0; i < n_vertices; i++) grafo->arestas[i] = criar_lista();

    grafo->n_vertices = n_vertices;
    grafo->n_arestas = 0;

    return grafo;
}

int criar_vertice(Grafo *g, int pos, char *nome, float lat, float lng) {
    PoP * pop = malloc(sizeof(PoP));
    pop->lat = lat;
    pop->lng = lng;
    pop->grau = 0;
    pop->nome = malloc(sizeof(nome));
    strcpy(pop->nome, nome);
    g->pontos[pos] = (PoP*) pop;
}

int inserir_aresta(Grafo *g, int orig, int dest, int capacidade) {
    int aresta_valida = verificar_aresta(g, orig, dest);
    if (aresta_valida != 0) return aresta_valida == 1 ? 0 : -1;

    double dist = distancia(g->pontos[orig]->lat, g->pontos[orig]->lng,
                            g->pontos[dest]->lat, g->pontos[dest]->lng);
    inserir_inicio(g->arestas[orig], dest, capacidade, dist);
    inserir_inicio(g->arestas[dest], orig, capacidade, dist);

    printf("Distancia %s a %s %.10lf\n", g->pontos[orig]->nome, g->pontos[dest]->nome, dist);
    g->pontos[orig]->grau++;
    g->pontos[dest]->grau++;
    g->n_arestas++;

    return 1;
}

int verificar_aresta(Grafo *g, int orig, int dest) {
    if (g == NULL) return -1;
    if (g->n_vertices < orig || g->n_vertices < dest || orig < 0 || dest < 0 || orig == dest) return -1;
    if (g->pontos[orig] == NULL || g->pontos[dest] == NULL) return -1;

    int existe = contem(g->arestas[orig], dest);

    return existe;
}

int num_vertices(Grafo *g) {
    if (g != NULL) return g->n_vertices;
    else return -1;
}

int grau_vertice(Grafo *g, int v) {

    if (g != NULL)
        if (g->pontos[v] != NULL || g->n_vertices > v)
            return g->pontos[v]->grau;

    return -1;
}

int eh_adjacente(Grafo *g, int orig, int dest) {
    int aresta_valida = verificar_aresta(g, orig, dest);
    if (aresta_valida <= 0) return 0;

    return contem(g->arestas[orig], dest);
}

int consultar_aresta(Grafo *g, int orig, int dest, int *capacidade, double *distancia) {
    int aresta_valida = verificar_aresta(g, orig, dest);
    if (aresta_valida <= 0) return aresta_valida;

    int p;
    double d;

    buscar_elemento(g->arestas[orig], dest, &p, &d);

    if (capacidade != NULL) *capacidade = p;
    if(distancia != NULL) *distancia =  d;
    return 1;
}

int remover_aresta(Grafo * g, int orig, int dest) {
    int aresta_valida = verificar_aresta(g, orig, dest);
    if (aresta_valida <= 0) return aresta_valida;

    remover_elemento(g->arestas[orig], dest);
    remover_elemento(g->arestas[dest], orig);

    g->pontos[orig]->grau--;
    g->pontos[dest]->grau--;
    g->n_arestas--;

    return 1;
}

void mostrar_adjacentes(Grafo *g, int vertice) {
    if (g == NULL) {
        printf("Grafo inexistente\n");
        return;
    }
    if (g->n_vertices < vertice || vertice < 0) {
        printf("Vértice inválido\n");
        return;
    }
    printf("| %02d |\t", vertice);
    if (vazia(g->arestas[vertice])) printf("O vertice [%d] não possui adjacentes", vertice);
    else
        mostrar_lista(g->arestas[vertice]);
    printf("\n");
}

void mostrar_grafo(Grafo *g) {
    if (g == NULL) {
        printf("Grafo inexistente\n");
        return;
    }
    int i, j;
    printf("Vertices\tAdjacentes\n");
    for (i = 0; i < g->n_vertices; i++) {
        mostrar_adjacentes(g, i);
    }
}

void menor_transferencia(Grafo *g, int orig, int dest, double size) {
    if (g != NULL) {
        int  * rota = calloc(g->n_vertices, sizeof(int));
        double * menor_caminho;
        int i;
        dijkstra(g, orig, dest, menor_caminho, rota);
        for (i = 0; i < g->n_vertices; i++)printf("%d _ ", rota[i]);
        printf("\nCaminho que o caminho percorrerá:\n");
        mostrar_caminho(g, orig, dest, rota, size);
        double t = tempo_de_envio(g, orig, dest, rota, size);
        printf("\nO tempo para o envio será de %.3lfs\n", t);
    }
}

double tempo_de_envio(Grafo *g, int orig, int dest, int *rota, double arq_size){
    if(orig == dest) return 0;
    int cap;
    consultar_aresta(g, dest, rota[dest], &cap, NULL);
    return (arq_size/cap) + tempo_de_envio(g, orig, rota[dest],rota, arq_size);
}

void dijkstra(Grafo *g, int orig, int dest, double *dist, int * ancestrais) {
    if (g == NULL)return;

    int  cap, i, j, aux, n_vertices = g->n_vertices;
    double d, d_aux;


    int * visitados = calloc(n_vertices , sizeof(int));
    dist = malloc(g->n_vertices * sizeof(double));

    for (i = 0 ; i < n_vertices; i++) ancestrais[i] = -1;


    for (i = 0; i < n_vertices; i++)dist[i] = INT_MAX;

    visitados[orig] = 1;

    for (i = 0; i < n_vertices; i++) {
        if (eh_adjacente(g, orig, i) && i != orig) {
            consultar_aresta(g, orig, i, &cap, &d);
            dist[i] = (1.0/cap)*d;
            ancestrais[i] = orig;
        }
    }

    aux = orig;

    for ( i = 0; i < n_vertices-1; i++) {

        for (j = 0; j < n_vertices; j++)
            if (visitados[j] == 0 && dist[aux] >= dist[j])aux = j;

        visitados[aux] = 1;
        printf("\nAnalisando: %s\n", g->pontos[aux]->nome);
        for (j = 0; j < n_vertices; j++) {
            if (visitados[j] == 0 && eh_adjacente(g, aux, j)) {
               
                consultar_aresta(g, aux, j, &cap, &d);  
                printf("%s( ", g->pontos[j]->nome);
               
                d_aux = dist[aux] + (1.0/cap)*d;
                printf("%.3lf - %.3lf) ", d_aux, dist[j]);
                if (d_aux < dist[j]) {
                    dist[j] = d_aux;
                    ancestrais[j] = aux;
                }
            }
        }
        printf("\n\n");
        for(j=0; j< n_vertices; j++) printf("%s : %lf; ", g->pontos[j]->nome, dist[j]);
        printf("\n");

        aux = orig;
    }

}

void mostrar_caminho(Grafo *g, int orig, int dest, int *ancestrais, double arq_size) {
    if (orig == dest)
        printf("%s", g->pontos[orig]->nome);
    else if (ancestrais[dest] == -1)
        printf("Impossível enviar de %s para %s\n", g->pontos[orig]->nome, g->pontos[dest]->nome);
    else {
        mostrar_caminho(g, orig, ancestrais[dest], ancestrais, arq_size);
        printf("->%s ", g->pontos[dest]->nome);
    }
}

void liberar_grafo(Grafo ** g) {
    if (*g == NULL) return;
    int i;
    for (i = 0; i < (*g)->n_vertices; i++) liberar_lista(&((*g)->arestas[i]));
    free((*g)->arestas);
    for (i = 0 ; i < (*g)->n_vertices; i++)
        if ((*g)->pontos[i] != NULL) {
            free((*g)->pontos[i]->nome);
            free((*g)->pontos[i]);
        }
    free((*g)->pontos);
    free((*g));
    *g = NULL;
    g = NULL;
}